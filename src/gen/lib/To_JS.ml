(*
   Convert a JSON grammar to JavaScript for better readability when
   debugging.
*)

open Printf
open Tree_sitter_t
open Indent.Types

let flatten nested_list =
  List.map (fun nodes -> Inline nodes) nested_list

(* Produce a javascript quoted string literal *)
let str s =
  Yojson.Safe.to_string (`String s)

let pattern s =
  let buf = Buffer.create (String.length s + 5) in
  Buffer.add_string buf "/";
  String.iter (function
    | '/' -> Buffer.add_string buf "\\/"
    | '\\' -> Buffer.add_string buf "\\\\"
    | c -> Buffer.add_char buf c
  ) s;
  Buffer.add_string buf "/";
  Buffer.contents buf

let rule s =
  sprintf "$.%s" s

let pp_conflict rule_list =
  let rules = List.map rule rule_list |> String.concat ", " in
  [ Line (sprintf "[%s]" rules) ]

let rec map (f : ?prefix:string -> ?is_last:bool -> _ -> _) xs =
  match xs with
  | [] -> []
  | [x] -> [f ~is_last:true x]
  | x :: xs -> f ~is_last:false x :: map f xs

let rec pp_body ?(prefix = "") ?(is_last = true) body =
  let cons, args =
    match body with
    | SYMBOL s -> rule s, None
    | STRING s -> str s, None
    | PATTERN s -> pattern s, None
    | BLANK -> "\"\" /* blank */", None
    | REPEAT x -> "repeat", Some (pp_body x)
    | REPEAT1 x -> "repeat1", Some (pp_body x)
    | CHOICE [x; BLANK] -> "optional", Some (pp_body x)
    | CHOICE xs -> "choice", Some (map pp_body xs |> flatten)
    | SEQ xs -> "seq", Some (map pp_body xs |> flatten)
    | PREC (_prec_value, _rule_body) -> "prec", Some []
    | PREC_DYNAMIC (_int, _rule_body) -> "prec.dynamic", Some []
    | PREC_LEFT (_prec_value, _rule_body) -> "prec.left", Some []
    | PREC_RIGHT (_prec_value, _rule_body) -> "prec.right", Some []
    | ALIAS _alias -> "alias", Some []
    | FIELD (_ident, _rule_body) -> "field", Some []
    | IMMEDIATE_TOKEN _rule_body -> "token.immediate", Some []
    | TOKEN _rule_body -> "token", Some []
  in
  match args with
  | None ->
      [ Line (sprintf "%s%s%s" prefix cons (if is_last then "" else ",")) ]
  | Some args ->
      [
        Line (sprintf "%s%s(" prefix cons);
        Block args;
        Line (sprintf ")%s" (if is_last then "" else ","))
      ]

let pp_rule (name, body) =
  pp_body ~prefix:(sprintf "%s: ($) => " name) body

let pp_grammar (x : grammar) : Indent.t =
  [
    Line "// Generated by 'ocaml-tree-sitter to-js";
    Line "module.exports = grammar({";
    Block [
      Line (sprintf "name: %s," (str x.name));
      Line "conflicts: ($) => [";
      Block (List.map pp_conflict x.conflicts |> flatten);
      Line "],";
    ];
    (* TODO: word, extras, inline, precedences, externals, supertypes, rules *)
    Line "});";
    Line "rules: {";
    Block (List.map pp_rule x.rules |> flatten);
    Line "}";
  ]

let run input_path output_path =
  let grammar =
    Atdgen_runtime.Util.Json.from_file Tree_sitter_j.read_grammar input_path
  in
  let tree = pp_grammar grammar in
  Indent.to_file output_path tree
